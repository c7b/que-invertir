# ¿Qué Invertir? - LLM Context Guide

## IMPORTANT: READ BEFORE SUGGESTING CHANGES

### Context Rules

1. **DO NOT** suggest features without reviewing the full codebase context.
2. **DO NOT** propose new providers or authentication systems.
3. **DO NOT** suggest architectural changes without understanding current constraints.

## Project Overview

A Next.js web application that scrapes and compares investment yields from major Mexican investment platforms including CETES, Nu Bank, SuperTasas, Finsus, Klar, Stori and Covalto. The application provides real-time comparison through a clean interface.

## Technology Stack

- **Frontend**: Next.js with TypeScript
- **Styling**: Tailwind CSS
- **Database**: Supabase (PostgreSQL)
- **Deployment**: Vercel
- **Scraping**: Puppeteer & Fetch API
- **Caching**: In-memory + Database

## Project Structure

```bash
QUE-INVERTIR/
├── app/
│   ├── api/
│   │   ├── consolidate/      # Data consolidation endpoint
│   │   ├── investments/      # Consolidated data retrieval
│   │   ├── cron/            # Automated updates
│   │   └── scrape/          # Individual and bulk scraping endpoints
│   ├── layout.tsx
│   └── page.tsx             # Main comparison interface
├── lib/
│   ├── scrapers/            # Individual scraper implementations
│   ├── cache.ts             # 5-minute memory cache
│   ├── consolidate.ts       # Data consolidation logic
│   ├── supabase.ts          # Database operations
│   └── utils.ts             # Shared utilities
└── types/                   # TypeScript definitions
```


## Core Components

### Data Types

```typescript
type Product = {
  name: string;
  yield: number;
  termDays: number;
  originalTerm: string;
};
```

### Core Types

```typescript
export type Provider = 'nu' | 'cetes' | 'supertasas';

export interface ScrapingData {
  provider: Provider;
  date: string;
  products: Product[];
  success: boolean;
  error?: string;
}

export interface DbRecord {
  id: string;
  provider: Provider;
  data: ScrapingData;
  created_at: string;
}
```

### Database Schema

```sql
-- Main scraping table
CREATE TABLE scraping_history (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  provider TEXT NOT NULL,
  data JSONB NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc', now()) NOT NULL
);

-- Consolidated view table
CREATE TABLE consolidated_view (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  consolidated_data JSONB NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc', now()) NOT NULL
);

-- Indexes for performance
CREATE INDEX idx_scraping_history_provider ON scraping_history(provider);
CREATE INDEX idx_scraping_history_created_at ON scraping_history(created_at DESC);
```

### Required Environment Variables

```bash
NEXT_PUBLIC_SUPABASE_URL=XXX
SUPABASE_SERVICE_ROLE_KEY=XXX
NEXT_PUBLIC_SUPABASE_ANON_KEY=XXX
CRON_SECRET=XXX
```

## Key Code Patterns to Preserve

1. **Scraping Pattern:**

   ```typescript
   export async function scrapeProvider(): Promise<ScrapingData> {
     let browser;
     try {
       browser = await puppeteer.launch({ headless: true });
       // Scraping logic
       return {
         provider: 'provider_name',
         date: new Date().toISOString(),
         products: [...],
         success: true
       };
     } catch (error) {
       if (browser) await browser.close();
       throw error; // Let API route handle errors
     }
   }
   ```

2. **API Route Pattern:**

   ```typescript
   export async function GET() {
     try {
       const isFresh = await isDataFresh('provider');
       if (isFresh) {
         return cached_data;
       }
       // Scraping and storage logic
     } catch (error) {
       // Error handling
     }
   }
   ```

## API Endpoints

```typescript
// Scraping endpoints
GET /api/scrape/all          // Scrapes all providers
GET /api/scrape/[provider]   // Scrapes specific provider

// Consolidation endpoints
GET /api/consolidate         // Consolidates latest data
GET /api/investments         // Gets consolidated view

// CRON endpoint (protected)
GET /api/cron                // Triggers update cycle
```

## Scraping Methods

1. **Direct API Call:**
   - CETES (government bonds)
   - Simple fetch requests
   - JSON response parsing

2. **Puppeteer Scraping:**
   - Nu
   - SuperTasas
   - Finsus
   - Klar
   - Stori
   - Covalto
   - Browser simulation
   - DOM parsing

## Cache Implementation

```typescript
const CACHE_DURATION = 1000 * 60 * 5; // 5 minutes

type CacheItem = {
  data: any;
  timestamp: number;
};

const cache: Map<string, CacheItem> = new Map();
```

- In-memory cache with 5-minute duration
- Automatic invalidation
- Map-based implementation


## Error Handling Strategy

1. **Scraping Errors:**
   - Log error details
   - Throw error to API route
   - No fallback data

2. **API Errors:**
   - **500**: Failed scraping
   - **401**: Invalid CRON authentication
   - **200**: Successful scrape

## Current Business Rules

1. **Data Freshness:**
   - Memory cache: 5 minutes
   - Consolidated data: 12 hours
   - Individual scrapes: As needed

2. **Required Product Fields:**
   - `name` (Spanish)
   - `yield` (number)
   - `termDays` (number)
   - `originalTerm` (string)

## Data Flow

1. CRON job triggers (every 6 hours by default)
2. Scraping process executed for all providers
3. Data consolidated into single view
4. Results stored in consolidated_view table
5. Frontend fetches single consolidated endpoint
6. Memory cache handles frequent requests

```yaml
# render.yaml
services:
  - type: web
    name: que-invertir
    env: node
    buildCommand: npm install && npm run build
    startCommand: npm start

  - type: cron
    name: que-invertir-update
    schedule: "0 */6 * * *"  # Every 6 hours
    httpMethod: GET
    url: /api/cron
```


## SEO Configuration

```typescript
export const metadata: Metadata = {
  title: "¿Qué Invertir? - Comparador de Rendimientos",
  description: "Compara tasas de rendimiento de CETES, Nu y SuperTasas en tiempo real",
  locale: "es_MX",
  type: "website",
};
```

## Current Limitations

- Limited to seven providers (CETES, Nu, SuperTasas, Finsus, Klar, Stori, Covalto)
- No user authentication
- No historical data tracking
- 6-hour update frequency
- No yield comparison adjustments

## Development Guidelines

- Maintain TypeScript types
- Follow existing error handling patterns
- Preserve bilingual approach (English code, Spanish UI)
- Keep scraping logic isolated per provider
- Use provided code patterns for consistency

## When Suggesting Optimizations

1. **Focus on:**
   - Error resilience
   - Cache efficiency
   - Type safety
   - Performance

2. **Avoid:**
   - New features
   - Additional dependencies
   - Complex state management
   - Authentication systems